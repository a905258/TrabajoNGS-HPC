---
title: 'FINAL WORK: NGS & HPC'
author: "The big five"
output: html_document
bibliography: FinalWork.bib
biblio-style: "apalike"
link-citations: true
---


BACKGROUND {data-icon="fa-dna"}
===================================== 

Column 1
--------------------------------------------------

### What is Bladder Cancer?

Explicar un poco del bladder cancer y mencionar qué vamos a intentar replicar del paper

Column 2
--------------------------------------------------

### Bladder Cancer

Foto

PREPARACIÓN DE MUESTRAS {data-icon="fa-flask"}
===================================== 

Poner abajo el sbatch de FastQC y MultiQC


```{r}

```


DNA-SEQ {data-icon="fa-flask"}
=====================================     

### Descargar FASTA  y hacer BWA index

First the BWA samples were obtained and then the index had to be built. To build it the fasta file of the reference genome was obtained from the Ensembl webpage. To perform this task no Atlas job was performed, the fasta was direcltly downloaded by using the command line:

```{r}
wget ftp://ftp.ensembl.org/pub/release-106/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz
```

After downloading the fasta file of the reference genome we used it to make the index for all the .BAM genomic samples, which were stored in the resultsBWA directory. First the ATLAS' resources used were 1GB of memory and we set a 1 hour job. This failed, as the index needed more memory to be built. For this reason the memory was increased to 100GB randomnly. In the end the job was completed but after analyzing the memory efficiency of the resources used (1 hour and 100GB) only 4.33GB were actually used. Therefore the Memory effiency was only a 4.33%. On the other hand the CPU Efficiency was 99.06% which is really good and the CPU utilized was 52 minutes and 49 secons, which is a value within our set period. In the future, to perform another BWA index it would be recommended to only used around 5GB of memory and again 1 hour of CPU time, if the index is going to be built with the same number of samples, which is approx 25 samples (mirar cuantas fueron).

```{r cars}

#!/bin/bash
#SBATCH --job-name=index_bai
#SBATCH --account=biomedicine
#SBATCH --partition=biomedicine
#SBATCH --cpus-per-task=1
#SBATCH --nodes=1
#SBATCH --mem=100G
#SBATCH --time=1:00:00

cd /scratch/arubio/bin
./ijob
cd /scratch/arubio/bin
. moduleloadNGS
cd /scratch/arubio/DNASeq/resultsBWA
for SAMPLE in /scratch/arubio/DNASeq/resultsBWA/*bam;
do
samtools index $SAMPLE
done

```


### BWA



### Haplotypecaller



### VCF



### MAF




RNA-SEQ {data-icon="fa-calculator"}
=====================================

### Kallisto

La parte de Laura y Guille


### Procesamiento de datos RNA-Seq

```{r echo=TRUE, message = FALSE, cache = TRUE, warning=FALSE}
library(readr)
library(sleuth)
library(biomaRt)
library(clusterProfiler)
library(org.Hs.eg.db)
library(ggplot2)
library(gplots)
library(ggrepel)
library(EnsDb.Hsapiens.v79)
```

Descarga de la matriz datos de ADI

```{r eval=FALSE, message = FALSE, echo=TRUE}
samples <- read_csv("samples_finalwork.csv",col_names = FALSE)

# View(samples)

colnames(samples) <- c("ID", "library_strategy", "base_pair_fragment", "Bioproject", "Biosample", "Accession", "X7", "library_selection", "library_source", "library_name", "end_date", "X12", "X13", "Run", "SRS", "SRA_study", "sample_name", "read_length", "center_name", "data_type", "sra", "ncbi", "library_instrument", "library_layout", "organism", "seq_type", "Published")

samples$sample_ID <- sapply(strsplit(samples$sample_name, "\\.|_"), function(X) X[1]) #selecciona la primera parte de antes de la "_"
samples$sample_type <- sapply(strsplit(samples$sample_name, "\\.|_"), function(X) X[2]) # selecciona la segunda parte de antes de la "_"
```

biomaRt

```{r eval=FALSE, message = FALSE, echo=TRUE}
# Annotation
# Get all the transcripts, genes, go_id and domains

mart <- biomaRt::useMart(host = 'may2021.archive.ensembl.org',
                         biomart = "ensembl",
                         dataset =   "hsapiens_gene_ensembl") # hsapiens for human
Atributos <- listAttributes(mart)

GeneTransciptLocation <- getBM(attributes=c("ensembl_gene_id","ensembl_transcript_id","chromosome_name","transcript_start","transcript_end"),mart=mart)
```


<font size="4"> **Load and process the data generated with Kallisto** </font>


```{r eval=TRUE, message = FALSE, cache = TRUE}
base_dir <- "/home/osboxes/Desktop/NGSFolder/FinalWork_NGS_HPC/FinalWork_NGS_HPC/samples" #base_dir = directory where the output of kallisto is stored
sample_id <- dir(base_dir) #sample_id = the names of the folders.

dirsample<-(paste0(base_dir,"/",sample_id[1]))
dirtoload <- paste0(dirsample,"/","abundance.tsv")
RNASeq <- read.delim(dirtoload,sep = "\t", colClasses = c(NA,"NULL","NULL","NULL",NA))
for (n in 2:length(sample_id)){
  dirsample<-(paste0(base_dir,"/",sample_id[n]))
  dirtoload <- paste0(dirsample,"/","abundance.tsv")
  RNASeq[,n+1] <- read.delim(dirtoload,sep = '\t', colClasses = c('NULL','NULL','NULL','NULL',NA))
}

rownames(RNASeq) <- sapply(strsplit(as.character(RNASeq[,1]),"\\|"),function(X) return(X[1]))
RNASeq<-RNASeq[,-1]
RNASeq2<-as.matrix(RNASeq)
colnames(RNASeq2)<-sample_id
```


<font size="4"> **Design and contrast matrices** </font>

La explicación de la matriz de diseño y contraste

```{r}
model_matrix <- model.matrix(~ sample_ID + sample_type, data = samples)
```


<font size="4"> **Sleuth ** </font>

```{r eval=FALSE, message = FALSE, echo=TRUE}
samples_red <- samples[which(samples$Run %in% sample_id),]
samples_red <- samples_red[match(sample_id, samples_red$Run),]

#With the next line we obtain the complete path
kal_dirs <- sapply(sample_id, function(id) file.path(base_dir,id))

#Build a data.frame with the sample ID, patient ID, condition (normal/cancer) and the kallisto directories for each sample. 
s2c <- data.frame(sample = sample_id,
                  sample_ID = samples_red$sample_ID,
                  sample_type = samples_red$sample_type)

#check that it is ordered
if (!identical(as.vector(s2c$sample),names(kal_dirs))){
  iix <- match(s2c$sample,names(kal_dirs))
  kal_dirs<-kal_dirs[iix]
}
s2c <- dplyr::select(s2c, sample = sample, sample_ID = sample_ID, sample_type = sample_type)
s2c <- dplyr::mutate(s2c, path = kal_dirs)

#Assign the condition value to the intercept
s2c$sample_type <- relevel(as.factor(s2c$sample_type), "Normal") 

s2c_ordered <- s2c[with(s2c, order(sample_type)),]
```



```{r}
# Load the kallisto processed data into the object
s1 <- sleuth_prep(s2c_ordered, extra_bootstrap_summary=T) 

# Estimate parameters for the sleuth response error measurement (full) model
so <- sleuth_fit(s1, ~ sample_ID + sample_type, fit_name =  'full')

# Estimate parameters for the sleuth reduced model
so <- sleuth_fit(so, ~ sample_ID, fit_name = 'reduced')

# Perform differential analysis (testing)
so <- sleuth_lrt(so,'reduced', 'full')

# In order to see the desing matrix
mod <- so$fits$full$design_matrix

#Read the Sleuth object

#tpm not normalized
RNASeq_tpm_raw <- sleuth_to_matrix(so,"obs_raw","tpm")

#counts not normalized
RNASeq_counts_raw <- sleuth_to_matrix(so,"obs_raw","est_counts")

#tpm normalized
RNASeq_tpm_norm <- sleuth_to_matrix(so,"obs_norm","tpm")

#counts normalized
RNASeq_counts_norm <- sleuth_to_matrix(so,"obs_norm","est_counts")
```



```{r}
# Statistical Analysis result
sleuth_table <- sleuth_results(so, 'reduced:full', 'lrt', show_all = FALSE)
sleuth_significant <- dplyr::filter(sleuth_table, qval <= 0.001)
head(sleuth_significant, 20)

sig_transcripts <- sapply(strsplit(sleuth_significant$target_id,"\\."),function(X) return(X[1]))
```


### Gene Ontology

En este apartado se usarán los datos cargados de Ensembl para relacionar los genes con los transcritos.

```{r echo=TRUE, message = FALSE, cache = TRUE}
iij <- which(GeneTransciptLocation$ensembl_transcript_id %in% sig_transcripts)
sig_genes <- GeneTransciptLocation$ensembl_gene_id[iij]

universe <- unique(GeneTransciptLocation$ensembl_gene_id)
```

```{r eval=TRUE, message = FALSE, cache = TRUE}
enrichGO <- clusterProfiler::enrichGO(gene = sig_genes, OrgDb = "org.Hs.eg.db",
                                          keyType ='ENSEMBL',  ont ='BP', pvalueCutoff = 0.01,
                                          pAdjustMethod = 'fdr', universe = universe,
                                          qvalueCutoff = 0.05, minGSSize = 5, maxGSSize = 600,
                                          readable ='FALSE', pool = 'FALSE')	

database_enrichgo <- data.frame(enrichGO)
```



```{r echo=TRUE, message = FALSE, cache = TRUE}
# We use simplify to remove redundant GO terms

enrichGO@result <- enrichGO@result[which(enrichGO@result$p.adjust < 0.05),]

enrichGO_simplified <- simplify(enrichGO, cutoff=0.7, by="p.adjust", select_fun=min)

database_enrichGO_simplified <- data.frame(enrichGO_simplified)
```



```{r eval=TRUE, message = FALSE, cache = TRUE}
# Dotplots

dotplot_enrichGO_simplified <- enrichplot::dotplot(enrichGO_simplified, showCategory=20) + ggtitle("Dotplot")
dotplot_enrichGO_simplified


# Enrichment Maps

emapplot_enrichGO_simplified <- emapplot(enrichGO_simplified) + theme(plot.title = element_text(hjust = 0.5)) + ggtitle("Enrichment Map")
emapplot_enrichGO_simplified


# Other plots

cnetplot(enrichGO_simplified)
```



```{r}
sig_genes_symbol_ens <- ensembldb::select(EnsDb.Hsapiens.v79, keys = sig_genes, keytype = "GENEID", columns = c("SYMBOL","GENEID"))
sig_genes_symbol <- sig_genes_symbol_ens[,1]

genes_paper_RNA <- c("STAG2","ESPL1","FGFR3","TACC3") #genes que aparecen en el abstract. STAG2 y ESPL1 están relacionados con la función de "sister chromatid cohesion and segregation"
genes_conocidos <- c("TP53", "HRAS", "FGFR3", "PIK3CA", "RB1", "KRAS", "TSC1") 
chrom_rem_genes <- c("UTX", "ARID1A", "MLL-MLL3", "CREBBP-EP300", "NCOR1", "CHD6")

database_enrichGO_simplified["GO:0007059","geneID"] #hay que eliminar las barras diagonales para tener un vector con los nombres de los genes

#PAra el variant calling debe haber mutaciones en los genes: UTX, MLL-MLL3, CREBBP-EP300, NCOR1,ARID1A, CHD6 (estos genes son los que se han descubierto)
#-Otros genes conocidos que estan mutados en bladder cancer: TP53, HRAS, FGFR3, PIK3CA, RB1, KARS, TSC1

which(genes_conocidos %in% sig_genes_symbol) #KRAS y HRAS
which(chrom_rem_genes %in% sig_genes_symbol) #NCOR1

## Hace falta comparar con la lista del choromosome segregation


database_enrichGO_simp_genes <- data.frame(database_enrichGO_simplified$geneID)
rownames(database_enrichGO_simp_genes) <- rownames(database_enrichGO_simplified)

genes_go_chrom_seg <- strsplit(database_enrichGO_simp_genes["GO:0007059",],"\\/")[[1]]

genes_go_chrom_seg_symbol_ens <- ensembldb::select(EnsDb.Hsapiens.v79, keys = genes_go_chrom_seg, keytype = "GENEID", columns = c("SYMBOL","GENEID"))
genes_go_chrom_seg_symbol <- genes_go_symbol_ens[,1]

table(genes_paper_RNA %in% genes_go_chrom_seg_symbol)
which(genes_paper_RNA %in% genes_go_chrom_seg_symbol) #STAG2, ESPL1 y TACC3
```


La parte de IGV

We were expecting to find also the FGFR3 gene, but we realized that the researchers from the scientific article that this project is based on analyzed the gene fussions, which is not related to the differential expression analysis that has been carried out. FOr this reason, another approach has been taken. 
We have used the following chunk of code to download the .bam and .bai files of the cancer sample number SRR645259 from subject B59. WIth this files, we have opened this files in the IGV software. As we were expecting to find a gene fussion, we were expecting to find each of the mates from genes FGFR3 and TACC3 

```{r}
scp a905208@atlas-fdr.sw.ehu.es:/scratch/arubio/DNAseq/resultsBWA/noduplicatesbam/SRR645259_aligned.bam* E:/NGSFolder/FinalWork_NGS_HPC/FinalWork_NGS_HPC/IGV_sample
```



### PCA


```{r echo=TRUE, message = FALSE, cache = TRUE}
rownames(RNASeq2) <- sapply(strsplit(rownames(RNASeq2), "\\."), function(X) X[1])

RNASeq2_filtered <- RNASeq2[sig_transcripts,]

col.order <- s2c_ordered$sample
RNASeq2_filt_ord <- RNASeq2_filtered[, col.order]

PCs <- prcomp(t(log2(1+RNASeq2_filt_ord)), center = T, retx = T)

data_PCA <- data.frame(samples = rownames(PCs$x),
                       ID = s2c_ordered$sample_ID,
                       type = s2c_ordered$sample_type,
                       PC1 = PCs$x[,1],
                       PC2 = PCs$x[,2])
```



```{r}
Fig_PCA <- ggplot(data_PCA) + geom_point(aes(x=PC1, y=PC2, color = type, size = 4)) + geom_label_repel(aes(x=PC1, y=PC2, label=ID)) +
  xlab('PC1') + ylab ('PC2') +
  theme_classic() + theme(legend.title = element_blank())
Fig_PCA
```


### Heatmap

```{r echo=TRUE, message = FALSE, cache = TRUE}
col.order <- s2c_ordered$sample
RNASeq2_filt_ord <- RNASeq2_filtered[, col.order]

num_cancer <- length(which(s2c_ordered$sample_type=="Cancer"))
num_normal <- length(which(s2c_ordered$sample_type=="Normal"))


heatmap_plot <- heatmap.2(x = log2(1+RNASeq2_filt_ord[1:50,]),
                       col="bluered",
                       trace="none",
                       ColSideColors = c(rep("orange", num_normal), rep("dark green", num_cancer)),
                       main="Normal vs Cancer",
                       margins = c(4,10)
)
legend(0.9,1.2, legend = c("Normal", "Cancer"),col = c("orange", "dark green"), lty= 1, lwd = 10, cex = 0.7)
```


### Boxplot

```{r echo=TRUE, message = FALSE, cache = TRUE}
sig_transcripts_sample <- sig_transcripts[1:10]
samples <- col.order
RNASeq2_filt_ord_sample <- log2(1+RNASeq2_filt_ord[sig_transcripts_sample,])

data_boxplot <- data.frame(transcripts = rep(sig_transcripts_sample, length(samples)), sample_id = rep(samples, each=length(sig_transcripts_sample)), sample_type = gl(2,length(sig_transcripts_sample)*num_normal,labels = c('Normal','Tumor')), values = as.vector(RNASeq2_filt_ord_sample))
data_boxplot$transcripts = as.factor(data_boxplot$transcripts)

Fig_boxplot <- ggplot(data = data_boxplot, aes(x = transcripts, y = values, fill = sample_type)) +
  geom_boxplot(width=0.5,position=position_dodge(width=0.5),outlier.shape = NA) +
  coord_cartesian(ylim =c(0,10))+ theme_classic() +
  stat_boxplot(geom="errorbar",position = position_dodge(width=0.5),width=0.2)+
  theme(plot.title = element_text(hjust = 0.5,margin=margin(0,0,10,0), size = 11),
        axis.text.x = element_text(hjust=0.9,vjust=0.9,angle=45),
        axis.text.y = element_text(margin=margin(0,0,0,10)),
        axis.title.x=element_blank(),
        axis.title.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(colour = "black", size = 1),
        axis.ticks.x = element_blank(),
        legend.title = element_blank()) +
  ggtitle('10 most significant transcripts ')
Fig_boxplot
```


CONCLUSIONS {data-icon="fa-clipboard-check"}
=====================================     



BIBLIOGRAPHY {data-icon="fa-book"}
=====================================     


